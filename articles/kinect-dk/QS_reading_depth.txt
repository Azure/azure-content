# Reading Depth Data

Need to read depth data from the device? It's easy!

**Contents**  
[Configuring the Device](#Configuring-the-Device)  
[Acessing Depth Data](#Acessing-Depth-Data)  
[Cleaning Up](#Cleaning-Up)  
[Full Source](#Full-Source)  

**Here are the functions we'll use:**  
[`k4a_device_start_cameras()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-device-start-cameras)  
[`k4a_capture_get_depth_image()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-capture-get-depth-image)  
[`k4a_image_get_buffer()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-image-get-buffer)  
[`k4a_image_get_width_pixels()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-image-get-width-pixels)  
[`k4a_image_get_height_pixels()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-image-get-height-pixels)  
[`k4a_image_release()`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-image-release)  

## Configuring the Device

After [opening an interface]() to the Azure Kinect DK device, you'll need to configure the camera for capturing depth data. There's only one item you really need to know about when configuring depth, and that's the `depth_mode`!

```C
k4a_device_configuration_t config = K4A_DEVICE_CONFIG_INIT_DISABLE_ALL;
config.depth_mode = K4A_DEPTH_MODE_NFOV_UNBINNED;
k4a_device_start_cameras(device, &config);
```

Here the `depth_mode` has a couple choices! Depending on the context of our application, we can request our depth data in different formats.

Are you running time constrained algorithms on the depth data? Maybe pick a 2X2BINNED mode so there's less data to operate on! Do you care more about what's far out directly ahead, rather than what's close and in the periphery? Use a narrow field of view with the NFOV modes!
| [`depth_mode`](https://review.docs.microsoft.com/en-us/azurekinect/api/k4a-depth-mode-t) | description |
|------------|-------------|
|`K4A_DEPTH_MODE_WFOV_UNBINNED`|Wide angle view (120x120), shallow depth (0.25-2.21m), high data resolution (1024x1024). Has a maximum framerate of 15.|
|`K4A_DEPTH_MODE_WFOV_2X2BINNED`|Wide angle view (120x120), shallow depth (0.25-2.88m), low data resolution (512x512).|
|`K4A_DEPTH_MODE_NFOV_UNBINNED`|Narrow angle view (75x65), far depth (0.5-3.86m), high data resolution (640x576).|
|`K4A_DEPTH_MODE_NFOV_2X2BINNED`|Narrow angle view (75x65), far depth (0.5-5.46m), low data resolution (320x288).|
|`K4A_DEPTH_MODE_PASSIVE_IR`|Raw feed from the IR camera (1024x1024)|
||Depth will be provided outside of indicated range depending on object reflectivity.|

## Acessing Depth Data

![](img/Depth.png)

When we capture a frame from the device, we can use `k4a_capture_get_depth_image` and `k4a_image_get_buffer` to get the raw depth data!

```C
// Capture a frame
k4a_capture_t capture;
k4a_device_get_capture(device, &capture, K4A_WAIT_INFINITE);
// Get the depth data and information from the current capture
k4a_image_t depth_image  = k4a_capture_get_depth_image(capture);
uint16_t   *depth_buffer = reinterpret_cast<uint16_t*>(k4a_image_get_buffer(depth_image));
int32_t width  = k4a_image_get_width_pixels (depth_image);
int32_t height = k4a_image_get_height_pixels(depth_image);
```

Depth information is provided as an array of unsigned 16 bit integers, representing millimeters from the camera. The array will hold a zero if the depth value isn't present for a particular pixel.

In this example, we'll just convert the depth data into a grayscale image, and save it to file!

```C
// Write this depth capture to an image file
// Allocate memory for an 8-bit grayscale image
uint8_t *file_color = static_cast<uint8_t *>(malloc(sizeof(uint8_t) * width*height));
// Convert each depth value to a shade of gray!
for (int32_t i = 0; i < width*height; i++)
{
    // Make a gray from the depth, white up close, black at 3 meters in the distance
    float depth_gray = 1-(depth_buffer[i] / 3000.0f);
    // Cap at 1.0, any higher and our uint8_t will overflow and wrap around
    depth_gray = depth_gray > 1.0f ? 1.0f : depth_gray;
    file_color[i] = static_cast<uint8_t>(depth_gray * 255);
}
tga_write("outDepth.tga", width, height, file_color, 1, 3);
free(file_color);
```

## Cleaning Up

Remember to shut down and release everything you've allocated or grabbed! Remember that frame captures should be freed after you're finished with them and before grabbing another frame.

```C
// Release all allocated resources, and shut down the Kinect
k4a_image_release(depth_image);
k4a_capture_release(capture);
k4a_device_stop_cameras(device);
k4a_device_close(device);
```

# Full Source

```C
#pragma comment(lib, "k4a.lib")
#include <k4a/k4a.h>
#include <stdio.h>
#include <stdlib.h>
void tga_write(const char *filename, uint32_t width, uint32_t height, uint8_t *data_bgra, uint8_t data_channels, uint8_t file_channels);
int main()
{
    // Open the first plugged in Kinect device
    k4a_device_t device = NULL;
    k4a_device_open(K4A_DEVICE_DEFAULT, &device);
    // Configure the Kinect to open a stream of 1024x1024 wide FOV at 5 frames per second
    k4a_device_configuration_t config = K4A_DEVICE_CONFIG_INIT_DISABLE_ALL;
    config.camera_fps = K4A_FRAMES_PER_SECOND_5;
    config.depth_mode = K4A_DEPTH_MODE_WFOV_UNBINNED;
    k4a_device_start_cameras(device, &config);
    // Wait until the first capture is available to us
    k4a_capture_t capture;
    k4a_device_get_capture(device, &capture, K4A_WAIT_INFINITE);
    // Get the depth data and information from the current capture
    k4a_image_t depth_image  = k4a_capture_get_depth_image(capture);
    uint16_t   *depth_buffer = reinterpret_cast<uint16_t*>(k4a_image_get_buffer(depth_image));
    int32_t width  = k4a_image_get_width_pixels (depth_image);
    int32_t height = k4a_image_get_height_pixels(depth_image);
    printf("Captured depth image, %dx%d\n", width, height);
    // Write this depth capture to an image file
    // Allocate memory for an 8-bit grayscale image
    uint8_t *file_color = static_cast<uint8_t *>(malloc(sizeof(uint8_t) * width*height));
    // Convert each depth value to a shade of gray!
    for (int32_t i = 0; i < width*height; i++)
    {
        // Make a gray from the depth, white up close, black at 3 meters in the distance
        float depth_gray = 1-(depth_buffer[i] / 3000.0f);
        // Cap at 1.0, any higher and our uint8_t will overflow and wrap around
        depth_gray = depth_gray > 1.0f ? 1.0f : depth_gray;
        file_color[i] = static_cast<uint8_t>(depth_gray * 255);
    }
    tga_write("outDepth.tga", width, height, file_color, 1, 3);
    free(file_color);
    // Release all allocated resources, and shut down the Kinect
    k4a_image_release(depth_image);
    k4a_capture_release(capture);
    k4a_device_stop_cameras(device);
    k4a_device_close(device);
    return 0;
}
void tga_write(const char *filename, uint32_t width, uint32_t height, uint8_t *data_bgra, uint8_t data_channels, uint8_t file_channels)
{
    FILE *fp = NULL;
    fopen_s(&fp, filename, "wb");
    if (fp == NULL) return;
    uint8_t header[18] = { 0,0,2,0,0,0,0,0,0,0,0,0, width % 256, (uint8_t)(width / 256), height % 256, (uint8_t)(height / 256), file_channels * 8u, 0x20 };
    fwrite(&header, 18, 1, fp);
    for (uint32_t i = 0; i < width*height; i++)
        for (uint32_t b = 0; b < file_channels; b++)
            fputc(data_bgra[(i*data_channels) + (b%data_channels)], fp);
    fclose(fp);
}
```
## Next Lab - [Reading RGB Data](ReadColor.md)